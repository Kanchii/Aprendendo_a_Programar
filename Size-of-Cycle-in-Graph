/* Este algoritmo tem dentro da DFS uma função para calcular o tamanho de um ciclo dentro de um grago */
/*
  Este algoritmo resolve o problema 1322 (Desejos das crianças) do URI Online Judge */
*/

#include <bits/stdc++.h>

using namespace std;

#define INF 0x3f3f3f3f
#define WHITE 0
#define GRAY 1
#define BLACK 2
#define PI 3.14159265
#define EPS 1e-9
#define MOD 1000000007
#define MAX 1000000

typedef unsigned long long int ull;
typedef long long ll;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int, int> pii;
typedef vector<pii> vpii;
typedef vector<vpii> vvpii;

int posCiclo[200100];
bool visited[200100];
int cor[200100];

int tamCiclo = -1;

void DFS(vector<vector<int> > &adj, int daVez, int prev, int hAtual){
	visited[daVez] = true;
	posCiclo[daVez] = hAtual; //Marca a posição do nodo atual

	for(int i = 0; i < adj[daVez].size(); i++){
		int v = adj[daVez][i];

		if(!visited[v]){
			DFS(adj, v, daVez, hAtual + 1);
		} else {
			if(v != prev and cor[v] != BLACK){ //Se voltei em uma posiço marcada que ainda não foi verificada ate o final
				tamCiclo = hAtual - posCiclo[v] + 1; //Então o tamanho deste ciclo eh minha posição atual menos a posicao do 
                                             //nodo que inicia o ciclo + 1 (+1 porque estamos tirando o nodo que inicia
                                             //o ciclo duas vezes
			}
		}
	}

	cor[daVez] = BLACK; //Marca o nodo atual como finalizado (significa dizer que ele ja foi totalmente processado)
}

int main() {
	ios_base::sync_with_stdio(false);

	int n, m;

	while(cin >> n >> m and (n or m)){
		int id = 0;
		tamCiclo = -1;
		map<int, int> mapa;
		vector<vector<int> > adj(2 * m + 1);
		bool valid = true;
		vector<pair<int, int> > repetido;
		for(int i = 0; i < m; i++){
			int a, b;
			cin >> a >> b;
			if(mapa.find(a) == mapa.end()){
				mapa[a] = id++;
			}
			if(mapa.find(b) == mapa.end()){
				mapa[b] = id++;
			}
			int v1 = mapa[a];
			int v2 = mapa[b];
			adj[v1].push_back(v2);
			adj[v2].push_back(v1);
		}
  
    /*Algoritmo eficiente para eliminar valores duplicados dentro de um vector*/
		for(int i = 0; i < id; i++){
            sort(adj[i].begin(),adj[i].end());
            adj[i].erase(unique(adj[i].begin(),adj[i].end()),adj[i].end());
            if(adj[i].size() > 2){ //Se uma criança deseja sentar ao lado de mais que duas pessoas, então o grafo eh invalido
            	valid = false;
            }
		}

		if(!valid){
			cout << "N" << endl;
		} else {
			memset(visited, false, sizeof(visited));
			memset(cor, WHITE, sizeof(cor));
			for(int i = 0; i < id; i++){
				if(!visited[i]){
					DFS(adj, i, -1, 0);
				}
			}
			if(tamCiclo == -1 or tamCiclo == n){
				cout << "Y" << endl;
			} else {
				cout << "N" << endl;
			}
		}

	}

    return 0;
}
